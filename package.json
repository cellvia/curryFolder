{
  "author": {
    "name": "Brandon Selway"
  },
  "name": "curryFolder",
  "version": "0.4.0",
  "description": "Curry / run all files in a folder",
  "main": "./index.js",
  "browserify-transform": "./transform.js",
  "dependencies": {
    "through": "~2.3.4",
    "escodegen": "~1.0.0",
    "falafel": "~0.3.1",
    "minimatch": "~0.2.14",
    "underscore": "~1.5.2"
  },
  "readme": "# curryFolder\r\n\r\nA utility for fs.reading/requiring/running operations on entire folders, works on server and client (via browserify + built in browserify transform);\r\n\r\n## Features\r\n\r\n## Usage\r\n\r\n### Curry the folder\r\n\r\nUse the curry method to create an object hash from a folder's contents.\r\n\r\n```javascript\r\nvar curryFolder = require(\"curryFolder\");\r\n\r\n//curry a folder into an object, recursively, and only including javascript files\r\nvar controllers = curryFolder.curry(__dirname + \"/lib/controllers\");\r\n```\r\n\r\nThe object hash is essentially like: { filename: require(filename), filename2: fs.readFileSync(filename2), etc... }\r\n\r\nJust this object can be useful in itself:\r\n\r\n```javascript\r\n//with a folder structure like:\r\n// ~/lib/controllers/errors/\r\n//                      .../500.js\r\n//                      .../403.js\r\n//                      .../402.js\r\n\r\nvar errorControllers = curryFolder.curry(__dirname + \"/lib/controllers/errors\");\r\napp.get( '/500', errorControllers.500 );\r\napp.get( '/403', errorControllers.403 );\r\napp.get( '/402', errorControllers.402 );\r\n```\r\n\r\n### Iterate over the hash\r\n\r\nWith this object hash you can use the attach function to iterate over each object\r\n\r\n\r\n\r\n## Methods\r\n\r\n\r\n### Method1\r\n\r\n\r\n## Options\r\n\r\nAll options are `false` by default.\r\n\r\n### debug\r\n\r\nDump a ton of stuff to stderr.\r\n\r\n### nobrace\r\n\r\nDo not expand `{a,b}` and `{1..3}` brace sets.\r\n\r\n### noglobstar\r\n\r\nDisable `**` matching against multiple folder names.\r\n\r\n### dot\r\n\r\nAllow patterns to match filenames starting with a period, even if\r\nthe pattern does not explicitly have a period in that spot.\r\n\r\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\r\nis set.\r\n\r\n### noext\r\n\r\nDisable \"extglob\" style patterns like `+(a|b)`.\r\n\r\n### nocase\r\n\r\nPerform a case-insensitive match.\r\n\r\n### nonull\r\n\r\nWhen a match is not found by `minimatch.match`, return a list containing\r\nthe pattern itself.  When set, an empty list is returned if there are\r\nno matches.\r\n\r\n### matchBase\r\n\r\nIf set, then patterns without slashes will be matched\r\nagainst the basename of the path if it contains slashes.  For example,\r\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\r\n\r\n### nocomment\r\n\r\nSuppress the behavior of treating `#` at the start of a pattern as a\r\ncomment.\r\n\r\n### nonegate\r\n\r\nSuppress the behavior of treating a leading `!` character as negation.\r\n\r\n### flipNegate\r\n\r\nReturns from negate expressions the same as if they were not negated.\r\n(Ie, true on a hit, false on a miss.)\r\n\r\n\r\n## Comparisons to other fnmatch/glob implementations\r\n\r\nWhile strict compliance with the existing standards is a worthwhile\r\ngoal, some discrepancies exist between minimatch and other\r\nimplementations, and are intentional.\r\n\r\nIf the pattern starts with a `!` character, then it is negated.  Set the\r\n`nonegate` flag to suppress this behavior, and treat leading `!`\r\ncharacters normally.  This is perhaps relevant if you wish to start the\r\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\r\ncharacters at the start of a pattern will negate the pattern multiple\r\ntimes.\r\n\r\nIf a pattern starts with `#`, then it is treated as a comment, and\r\nwill not match anything.  Use `\\#` to match a literal `#` at the\r\nstart of a line, or set the `nocomment` flag to suppress this behavior.\r\n\r\nThe double-star character `**` is supported by default, unless the\r\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\r\nand bash 4.1, where `**` only has special significance if it is the only\r\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\r\n`a/**b` will not.\r\n\r\nIf an escaped pattern has no matches, and the `nonull` flag is set,\r\nthen minimatch.match returns the pattern as-provided, rather than\r\ninterpreting the character escapes.  For example,\r\n`minimatch.match([], \"\\\\*a\\\\?\")` will return `\"\\\\*a\\\\?\"` rather than\r\n`\"*a?\"`.  This is akin to setting the `nullglob` option in bash, except\r\nthat it does not resolve escaped pattern characters.\r\n\r\nIf brace expansion is not disabled, then it is performed before any\r\nother interpretation of the glob pattern.  Thus, a pattern like\r\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\r\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\r\nchecked for validity.  Since those two are valid, matching proceeds.\r\n",
  "readmeFilename": "README.md",
  "_id": "curryFolder@0.4.0",
  "dist": {
    "shasum": "4bbed382a407aa48368cc3261dfc3235fb24ce65"
  },
  "_from": "/node/work/personal/_libs/curryFolder"
}
